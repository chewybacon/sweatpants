{"version":3,"sources":["../src/encode.ts","../src/decode.ts"],"names":[],"mappings":";AAiCO,SAAS,mBAAA,CACd,OAAA,EACA,OAAA,EACA,MAAA,EACsB;AAEtB,EAAA,MAAM,iBAAA,GAAgC;AAAA,IACpC,GAAG,MAAA;AAAA,IACH,kBAAA,EAAoB;AAAA,GACtB;AAGA,EAAA,MAAM,WAAA,GAAc,IAAA,CAAK,SAAA,CAAU,OAAO,CAAA;AAC1C,EAAA,MAAM,kBAAA,GAAqB,GAAG,OAAO;;AAAA;AAAA,EAA6C,WAAW,CAAA,CAAA;AAE7F,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,kBAAA;AAAA,IACT,MAAA,EAAQ;AAAA,GACV;AACF;;;ACpCA,SAAS,0BAA0B,OAAA,EAAiD;AAClF,EAAA,MAAM,cAAA,GAAiB,0CAAA;AACvB,EAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,OAAA,CAAQ,cAAc,CAAA;AAEpD,EAAA,IAAI,kBAAkB,EAAA,EAAI;AACxB,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,IAAI;AACF,IAAA,MAAM,WAAA,GAAc,OAAA,CAAQ,KAAA,CAAM,aAAA,GAAgB,eAAe,MAAM,CAAA;AACvE,IAAA,OAAO,IAAA,CAAK,MAAM,WAAW,CAAA;AAAA,EAC/B,CAAA,CAAA,MAAQ;AAEN,IAAA,OAAO,IAAA;AAAA,EACT;AACF;AAUO,SAAS,oBAAoB,OAAA,EAAyB;AAC3D,EAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,OAAA,CAAQ,uBAAuB,CAAA;AAC7D,EAAA,OAAO,aAAA,KAAkB,KAAK,OAAA,GAAU,OAAA,CAAQ,MAAM,CAAA,EAAG,aAAa,EAAE,IAAA,EAAK;AAC/E;AAyBO,SAAS,mBAAA,CACd,SACA,MAAA,EACgC;AAEhC,EAAA,IAAI,OAAA,GAAmB,OAAO,kBAAkB,CAAA;AAGhD,EAAA,IAAI,YAAY,MAAA,EAAW;AACzB,IAAA,OAAA,GAAU,0BAA0B,OAAO,CAAA;AAAA,EAC7C;AAGA,EAAA,IAAI,OAAA,KAAY,IAAA,IAAQ,OAAA,KAAY,MAAA,EAAW;AAC7C,IAAA,OAAA,GAAU,EAAC;AAAA,EACb;AAGA,EAAA,MAAM,YAAA,GAAe,oBAAoB,OAAO,CAAA;AAEhD,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,YAAA;AAAA,IACT;AAAA,GACF;AACF","file":"index.js","sourcesContent":["/**\n * Encoding utilities for x-elicit-context specification.\n * \n * Encodes context data into MCP elicit requests using two mechanisms:\n * 1. Schema extension (x-elicit-context field) - primary\n * 2. Message boundary encoding - fallback for compatibility\n */\nimport type { JsonSchema, EncodedElicitContext } from './types'\n\n/**\n * Encode context data into an elicit request.\n * \n * Adds context in two places for maximum compatibility:\n * - Primary: `x-elicit-context` field in JSON Schema\n * - Fallback: Message boundary encoding for clients that don't support schema extensions\n * \n * @param message - Human-readable message\n * @param context - Context data to encode\n * @param schema - JSON Schema for the response\n * @returns Encoded message and schema with context embedded\n * \n * @example\n * ```typescript\n * const encoded = encodeElicitContext(\n *   'Select a flight',\n *   { flights: [...], currency: 'USD' },\n *   { type: 'object', properties: { flightId: { type: 'string' } } }\n * )\n * \n * // encoded.schema has x-elicit-context extension\n * // encoded.message has boundary-encoded context appended\n * ```\n */\nexport function encodeElicitContext<TContext = Record<string, unknown>>(\n  message: string,\n  context: TContext,\n  schema: JsonSchema\n): EncodedElicitContext {\n  // Add context to schema extension (primary mechanism)\n  const schemaWithContext: JsonSchema = {\n    ...schema,\n    'x-elicit-context': context,\n  }\n\n  // Add context to message boundary (fallback mechanism)\n  const contextJson = JSON.stringify(context)\n  const messageWithContext = `${message}\\n\\n--x-elicit-context: application/json\\n${contextJson}`\n\n  return {\n    message: messageWithContext,\n    schema: schemaWithContext,\n  }\n}\n","/**\n * Decoding utilities for x-elicit-context specification.\n * \n * Extracts context data from MCP elicit requests and cleans messages.\n */\nimport type { JsonSchema, DecodedElicitContext } from './types'\n\n/**\n * Extract context from a message's boundary encoding.\n * \n * Looks for the `--x-elicit-context: application/json` boundary and parses\n * the JSON content that follows.\n * \n * @param message - Message with potential boundary encoding\n * @returns Parsed context or null if no boundary found\n */\nfunction extractContextFromMessage(message: string): Record<string, unknown> | null {\n  const boundaryMarker = '\\n--x-elicit-context: application/json\\n'\n  const boundaryIndex = message.indexOf(boundaryMarker)\n  \n  if (boundaryIndex === -1) {\n    return null\n  }\n  \n  try {\n    const contextJson = message.slice(boundaryIndex + boundaryMarker.length)\n    return JSON.parse(contextJson) as Record<string, unknown>\n  } catch {\n    // Invalid JSON in boundary - return null\n    return null\n  }\n}\n\n/**\n * Strip x-elicit-context boundary from message.\n * \n * Removes the boundary section to get the clean human-readable message.\n * \n * @param message - Message with potential boundary encoding\n * @returns Clean message without boundary\n */\nexport function stripMessageContext(message: string): string {\n  const boundaryIndex = message.indexOf('\\n--x-elicit-context:')\n  return boundaryIndex === -1 ? message : message.slice(0, boundaryIndex).trim()\n}\n\n/**\n * Decode context from an elicit request.\n * \n * Extraction priority:\n * 1. Schema extension (`x-elicit-context` field) - primary\n * 2. Message boundary encoding - fallback\n * 3. Empty object if no context found\n * \n * @param message - Elicit message (may have boundary encoding)\n * @param schema - JSON Schema (may have x-elicit-context extension)\n * @returns Decoded context and cleaned message\n * \n * @example\n * ```typescript\n * const { message, context } = decodeElicitContext(\n *   messageWithBoundary,\n *   schemaWithExtension\n * )\n * \n * // message is cleaned (boundary removed)\n * // context is extracted (typed by caller)\n * ```\n */\nexport function decodeElicitContext<TContext = Record<string, unknown>>(\n  message: string,\n  schema: JsonSchema\n): DecodedElicitContext<TContext> {\n  // Try schema extension first (clean JSON, preferred)\n  let context: unknown = schema['x-elicit-context']\n  \n  // Fall back to message boundary if schema extension not found\n  if (context === undefined) {\n    context = extractContextFromMessage(message)\n  }\n  \n  // Default to empty object if no context found\n  if (context === null || context === undefined) {\n    context = {}\n  }\n  \n  // Clean the message\n  const cleanMessage = stripMessageContext(message)\n  \n  return {\n    message: cleanMessage,\n    context: context as TContext,\n  }\n}\n"]}