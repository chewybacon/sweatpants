/**
 * TypeScript Code Generator
 * 
 * Generates TypeScript type definitions from MCP manifest data.
 */

import type { McpManifest, McpToolDefinition } from './fetch-manifest.ts'
import { jsonSchemaToTs, toPascalCase } from './json-schema-to-ts.ts'

/**
 * Options for code generation.
 */
export interface CodegenOptions {
  /** Include a header comment with source URL */
  includeHeader?: boolean
  /** Source URL for the header */
  sourceUrl?: string
}

/**
 * Generate TypeScript types from an MCP manifest.
 */
export function generateTypes(manifest: McpManifest, options: CodegenOptions = {}): string {
  const { includeHeader = true, sourceUrl } = options
  
  const lines: string[] = []
  
  // Header
  if (includeHeader) {
    lines.push('/**')
    lines.push(' * MCP Types - Generated by @sweatpants/cli')
    if (sourceUrl) {
      lines.push(` * Source: ${sourceUrl}`)
    }
    lines.push(` * Generated: ${new Date().toISOString()}`)
    lines.push(' */')
    lines.push('')
  }

  // Generate types for each tool
  for (const tool of manifest.tools) {
    lines.push(...generateToolTypes(tool))
    lines.push('')
  }

  // Generate the MCPToolRegistry interface
  lines.push(...generateToolRegistry(manifest.tools))

  return lines.join('\n')
}

/**
 * Generate types for a single tool.
 */
function generateToolTypes(tool: McpToolDefinition): string[] {
  const lines: string[] = []
  const toolPascal = toPascalCase(tool.name)

  // Tool params interface
  lines.push(`/**`)
  lines.push(` * Parameters for the ${tool.name} tool.`)
  if (tool.description) {
    lines.push(` * ${tool.description}`)
  }
  lines.push(` */`)
  lines.push(`export interface ${toolPascal}Params ${jsonSchemaToTs(tool.inputSchema)}`)
  lines.push('')

  // Elicit types
  const sweatpants = tool._meta?.['x-sweatpants']
  if (sweatpants?.elicits) {
    for (const [elicitKey, elicitDef] of Object.entries(sweatpants.elicits)) {
      const elicitPascal = toPascalCase(elicitKey)
      
      // Response type
      lines.push(`/**`)
      lines.push(` * Response type for ${tool.name} elicit: ${elicitKey}`)
      lines.push(` */`)
      lines.push(`export interface ${toolPascal}Elicit_${elicitPascal}_Response ${jsonSchemaToTs(elicitDef.response)}`)
      lines.push('')

      // Context type (if present)
      if (elicitDef.context) {
        lines.push(`/**`)
        lines.push(` * Context type for ${tool.name} elicit: ${elicitKey}`)
        lines.push(` */`)
        lines.push(`export interface ${toolPascal}Elicit_${elicitPascal}_Context ${jsonSchemaToTs(elicitDef.context)}`)
        lines.push('')
      }
    }
  }

  return lines
}

/**
 * Generate the MCPToolRegistry interface.
 */
function generateToolRegistry(tools: McpToolDefinition[]): string[] {
  const lines: string[] = []

  lines.push(`/**`)
  lines.push(` * Registry of all MCP tools with their types.`)
  lines.push(` */`)
  lines.push(`export interface MCPToolRegistry {`)

  for (const tool of tools) {
    const toolPascal = toPascalCase(tool.name)
    const sweatpants = tool._meta?.['x-sweatpants']

    lines.push(`  ${tool.name}: {`)
    lines.push(`    params: ${toolPascal}Params`)

    // Add elicits if present
    if (sweatpants?.elicits && Object.keys(sweatpants.elicits).length > 0) {
      lines.push(`    elicits: {`)
      
      for (const [elicitKey, elicitDef] of Object.entries(sweatpants.elicits)) {
        const elicitPascal = toPascalCase(elicitKey)
        const contextType = elicitDef.context 
          ? `${toolPascal}Elicit_${elicitPascal}_Context`
          : 'Record<string, never>'
        
        lines.push(`      ${elicitKey}: {`)
        lines.push(`        response: ${toolPascal}Elicit_${elicitPascal}_Response`)
        lines.push(`        context: ${contextType}`)
        lines.push(`      }`)
      }
      
      lines.push(`    }`)
    }

    // Add requires if present
    if (sweatpants?.requires) {
      lines.push(`    requires: {`)
      if (sweatpants.requires.elicitation !== undefined) {
        lines.push(`      elicitation: ${sweatpants.requires.elicitation}`)
      }
      if (sweatpants.requires.sampling !== undefined) {
        lines.push(`      sampling: ${sweatpants.requires.sampling}`)
      }
      lines.push(`    }`)
    }

    lines.push(`  }`)
  }

  lines.push(`}`)

  return lines
}
