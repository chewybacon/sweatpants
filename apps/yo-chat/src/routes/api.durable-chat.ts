/**
 * Durable Chat API Route
 *
 * This route uses the durable chat handler which provides:
 * - Pull-based streaming with LSN for reconnection
 * - Session management via SessionRegistry
 * - Multi-client fan-out from shared buffer
 *
 * Protocol:
 * - Request headers: X-Session-Id (optional), X-Last-LSN (optional)
 * - Response: NDJSON with {lsn, event} per line
 * - Response headers: X-Session-Id
 */
import { createFileRoute } from '@tanstack/react-router'
import { createDurableChatHandler } from '@tanstack/framework/handler/durable'
import {
  createSharedStorage,
  getSharedStores,
  setupDurableStreams as setupDurableStreamsWithConfig,
} from '@tanstack/framework/chat/durable-streams'
import {
  resolvePersona,
  ollamaProvider,
  openaiProvider,
  setupLogger,
} from '@tanstack/framework/chat'
import {
  ProviderContext,
  ToolRegistryContext,
  PersonaResolverContext,
  MaxIterationsContext,
} from '@tanstack/framework/chat'
import type { Operation } from 'effection'
import type { InitializerContext } from '@tanstack/framework/handler/durable'
import { env } from '@/env'

// Auto-discovered tools from src/tools/ (generated by @tanstack/framework)
import { toolList } from '../__generated__/tool-registry.gen'

// Combine all tools
const allTools = [...toolList]

// =============================================================================
// SHARED STORAGE (module-level, persists across requests)
// =============================================================================

/**
 * Shared storage for durable streams.
 *
 * This is created once at module load time and persists across all HTTP requests.
 * This enables:
 * - Session reconnection (client can disconnect and reconnect to same session)
 * - Multi-client fan-out (multiple clients reading same session)
 * - Proper cleanup (sessions cleaned up when all clients disconnect AND stream completes)
 *
 * Note: In production with multiple server instances, you'd use Redis or a database
 * instead of this in-memory shared storage.
 */
const sharedStorage = createSharedStorage<string>()

// Initializer hook that uses shared storage
const setupDurableStreams = function* (): Operation<void> {
  const { bufferStore, registryStore } = getSharedStores(sharedStorage)
  yield* setupDurableStreamsWithConfig({ bufferStore, registryStore })
}

const setupProvider = function* (ctx: InitializerContext): Operation<void> {
  // Dynamic provider selection based on request
  // Note: provider field is an extension not in the base ChatRequestBody type
  const body = ctx.body as { provider?: string }
  const providerName = body.provider || env.CHAT_PROVIDER
  const providerMap = {
    ollama: ollamaProvider,
    openai: openaiProvider,
  }

  const selectedProvider = providerMap[providerName as keyof typeof providerMap]
  if (!selectedProvider) {
    throw new Error(`Unknown provider: ${providerName}`)
  }

  yield* ProviderContext.set(selectedProvider)
}

const setupTools = function* (_ctx: InitializerContext): Operation<void> {
  yield* ToolRegistryContext.set(allTools)
}

const setupPersonaResolver = function* (_ctx: InitializerContext): Operation<void> {
  yield* PersonaResolverContext.set(resolvePersona)
}

const setupMaxIterations = function* (_ctx: InitializerContext): Operation<void> {
  yield* MaxIterationsContext.set(10)
}

// Create the durable handler with hook-based configuration
const durableChatHandler = createDurableChatHandler({
  initializerHooks: [
    setupLogger,  // Must be first to enable logging in other hooks
    setupDurableStreams,
    setupProvider,
    setupTools,
    setupPersonaResolver,
    setupMaxIterations,
  ],
})

export const Route = createFileRoute('/api/durable-chat')({
  server: {
    handlers: {
      POST: async ({ request }) => {
        return durableChatHandler(request)
      },
    },
  },
})
