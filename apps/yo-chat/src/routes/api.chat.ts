/**
 * Chat API Route
 *
 * Uses the durable streaming handler which provides:
 * - Session reconnection from last LSN
 * - Multi-client fan-out
 * - Full session replay
 *
 * Protocol:
 * - Request headers: X-Session-Id (optional), X-Last-LSN (optional)
 * - Response: NDJSON with {lsn, event} per line
 * - Response headers: X-Session-Id
 */
import { createFileRoute } from '@tanstack/react-router'
import { createChatHandler, type InitializerContext } from '@sweatpants/framework/handler'
import {
  createSharedStorage,
  getSharedStores,
  setupDurableStreams as setupDurableStreamsWithConfig,
} from '@sweatpants/framework/chat/durable-streams'
import {
  resolvePersona,
  ollamaProvider,
  openaiProvider,
  setupLogger,
} from '@sweatpants/framework/chat'
import {
  ProviderContext,
  ToolRegistryContext,
  PersonaResolverContext,
  MaxIterationsContext,
  PluginRegistryContext,
  McpToolRegistryContext,
  PluginSessionRegistryContext,
  PluginSessionManagerContext,
} from '@sweatpants/framework/chat'
import {
  createInMemoryToolSessionStore,
  createPluginRegistryFrom,
  createToolSessionRegistry,
  type ToolSessionSamplingProvider,
  type ToolSessionRegistry,
} from '@sweatpants/framework/chat/mcp-tools'
import { createPluginSessionManager, type PluginSessionManager } from '@sweatpants/framework/handler/durable'
import type { McpToolRegistry } from '@sweatpants/framework/handler/durable'
import type { Operation } from 'effection'
import { run } from 'effection'
import { env } from '@/env'

// Auto-discovered tools from src/tools/ (generated by @sweatpants/framework)
import { toolList } from '../__generated__/tool-registry.gen'

// MCP plugin tools (manually imported until auto-discovery is added)
import { bookFlightTool, bookFlightPlugin } from '../tools/book-flight'

// Combine all tools
const allTools = [...toolList]

// =============================================================================
// SHARED STORAGE (module-level, persists across requests)
// =============================================================================

/**
 * Shared storage for durable streams.
 *
 * This is created once at module load time and persists across all HTTP requests.
 * This enables:
 * - Session reconnection (client can disconnect and reconnect to same session)
 * - Multi-client fan-out (multiple clients reading same session)
 * - Proper cleanup (sessions cleaned up when all clients disconnect AND stream completes)
 *
 * Note: In production with multiple server instances, you'd use Redis or a database
 * instead of this in-memory shared storage.
 */
const sharedStorage = createSharedStorage<string>()

// Initializer hook that uses shared storage
const setupDurableStreams = function* (): Operation<void> {
  const { bufferStore, registryStore } = getSharedStores(sharedStorage)
  yield* setupDurableStreamsWithConfig({ bufferStore, registryStore })
}

const setupProvider = function* (ctx: InitializerContext): Operation<void> {
  // Dynamic provider selection based on request
  // Note: provider field is an extension not in the base ChatRequestBody type
  const body = ctx.body as { provider?: string }
  const providerName = body.provider || env.CHAT_PROVIDER
  const providerMap = {
    ollama: ollamaProvider,
    openai: openaiProvider,
  }

  const selectedProvider = providerMap[providerName as keyof typeof providerMap]
  if (!selectedProvider) {
    throw new Error(`Unknown provider: ${providerName}`)
  }

  yield* ProviderContext.set(selectedProvider)
}

const setupTools = function* (_ctx: InitializerContext): Operation<void> {
  yield* ToolRegistryContext.set(allTools)
}

const setupPersonaResolver = function* (_ctx: InitializerContext): Operation<void> {
  yield* PersonaResolverContext.set(resolvePersona)
}

const setupMaxIterations = function* (_ctx: InitializerContext): Operation<void> {
  yield* MaxIterationsContext.set(10)
}

// =============================================================================
// PLUGIN SETUP (MCP plugin tools with React UI elicitation)
// =============================================================================

/**
 * Create a simple MCP tool registry from an array of tools.
 */
function createMcpToolRegistry(mcpTools: { name: string }[]): McpToolRegistry {
  const map = new Map<string, unknown>()
  for (const tool of mcpTools) {
    map.set(tool.name, tool)
  }
  return {
    get: (name: string) => map.get(name),
    has: (name: string) => map.has(name),
    names: () => Array.from(map.keys()),
  }
}

// MCP plugin tools (with elicitation support)
const mcpPluginTools = [bookFlightTool]

// Plugin registry (handlers for elicitation)
// Note: Type assertion needed due to TypeScript variance with generic handlers
const pluginRegistry = createPluginRegistryFrom([bookFlightPlugin.client as any])

// MCP tool registry (for tool lookup)
const mcpToolRegistry = createMcpToolRegistry(mcpPluginTools)

/**
 * Mock sampling provider for plugin tools.
 * In production, this would wrap the actual chat provider.
 */
function createPluginSamplingProvider(): ToolSessionSamplingProvider {
  return {
    *sample(_messages, options) {
      // Simple mock that acknowledges the request
      const maxTokens = options?.maxTokens ?? 100
      return {
        text: `[Plugin sampling - would generate up to ${maxTokens} tokens]`,
        model: 'mock-model',
        stopReason: 'endTurn',
      }
    },
  }
}

/**
 * Shared plugin session registry and manager (module-level, persists across requests).
 * 
 * CRITICAL: Both must be created in a long-lived Effection scope so that tool
 * sessions survive across HTTP request boundaries. This enables multi-step
 * elicitation flows where:
 * 
 * 1. Request 1: Tool starts, emits pickFlight elicitation, session stays alive
 * 2. Request 2: User selects flight, tool resumes from the same session
 * 3. Request 2: Tool emits pickSeat elicitation, session stays alive
 * 4. Request 3: User selects seat, tool completes
 * 
 * The manager wraps the registry and tracks:
 * - Session wrappers (for server-side sampling)
 * - Last processed LSN per session (to avoid replaying old events on reconnect)
 * 
 * This pattern mirrors how yo-mcp creates its registry at server startup.
 */
let sharedPluginSessionRegistry: ToolSessionRegistry | null = null
let sharedPluginSessionManager: PluginSessionManager | null = null

// Create the registry and manager in a long-lived scope at module initialization
// This runs once when the module is first imported
const registryPromise = run(function* () {
  const store = createInMemoryToolSessionStore()
  const samplingProvider = createPluginSamplingProvider()
  const registry = yield* createToolSessionRegistry(store, { samplingProvider })
  const manager = yield* createPluginSessionManager({ registry })
  sharedPluginSessionRegistry = registry
  sharedPluginSessionManager = manager
  return { registry, manager }
})

const setupPlugins = function* (_ctx: InitializerContext): Operation<void> {
  yield* PluginRegistryContext.set(pluginRegistry)
  yield* McpToolRegistryContext.set(mcpToolRegistry)
  
  // Wait for registry and manager to be ready (they're created async at module load)
  // In practice, they should be ready by the time the first request arrives
  if (!sharedPluginSessionRegistry || !sharedPluginSessionManager) {
    // This shouldn't happen in normal operation, but handle it gracefully
    console.error('Plugin session registry/manager not ready yet')
    return
  }
  
  yield* PluginSessionRegistryContext.set(sharedPluginSessionRegistry)
  yield* PluginSessionManagerContext.set(sharedPluginSessionManager)
}

// Create the handler with hook-based configuration
// IMPORTANT: setupLogger must be first, setupDurableStreams must run before others
const chatHandler = createChatHandler({
  initializerHooks: [
    setupLogger, // Must be first to enable logging in other hooks
    setupDurableStreams,
    setupProvider,
    setupTools,
    setupPersonaResolver,
    setupMaxIterations,
    setupPlugins, // MCP plugin tools with React UI elicitation
  ],
})

export const Route = createFileRoute('/api/chat')({
  server: {
    handlers: {
      POST: async ({ request }) => {
        return chatHandler(request)
      },
    },
  },
})
