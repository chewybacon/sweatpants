/**
 * Chat API Route
 *
 * Uses the durable streaming handler which provides:
 * - Session reconnection from last LSN
 * - Multi-client fan-out
 * - Full session replay
 *
 * Protocol:
 * - Request headers: X-Session-Id (optional), X-Last-LSN (optional)
 * - Response: NDJSON with {lsn, event} per line
 * - Response headers: X-Session-Id
 */
import { createFileRoute } from '@tanstack/react-router'
import { createChatHandler, type InitializerContext } from '@sweatpants/framework/handler'
import {
  createSharedStorage,
  getSharedStores,
  setupDurableStreams as setupDurableStreamsWithConfig,
} from '@sweatpants/framework/chat/durable-streams'
import {
  resolvePersona,
  ollamaProvider,
  openaiProvider,
  setupLogger,
} from '@sweatpants/framework/chat'
import {
  ProviderContext,
  ToolRegistryContext,
  PersonaResolverContext,
  MaxIterationsContext,
  PluginRegistryContext,
  McpToolRegistryContext,
  PluginSessionRegistryContext,
  PluginSessionManagerContext,
} from '@sweatpants/framework/chat'
import {
  createInMemoryToolSessionStore,
  createPluginRegistryFrom,
  createToolSessionRegistry,
  type ToolSessionSamplingProvider,
  type ToolSessionRegistry,
} from '@sweatpants/framework/chat/mcp-tools'
import { createPluginSessionManager, type PluginSessionManager } from '@sweatpants/framework/handler/durable'
import type { McpToolRegistry } from '@sweatpants/framework/handler/durable'
import type { 
  ToolCall, 
  ChatResult,
  SampleResultBase,
  SampleResultWithToolCalls,
  SamplingToolCall,
  SamplingToolDefinition,
} from '@sweatpants/framework/chat'
import type { Operation } from 'effection'
import { run, each } from 'effection'
import { env } from '@/env'

// Auto-discovered tools from src/tools/ (generated by @sweatpants/framework)
import { toolList } from '../__generated__/tool-registry.gen'

// MCP plugin tools (manually imported until auto-discovery is added)
import { bookFlightTool, bookFlightPlugin } from '../tools/book-flight'
import { tictactoeTool, tictactoePlugin } from '../tools/tictactoe'
import { playTttTool, playTttPlugin } from '../tools/play-ttt'

// Combine all tools
const allTools = [...toolList]

// =============================================================================
// SHARED STORAGE (module-level, persists across requests)
// =============================================================================

/**
 * Shared storage for durable streams.
 *
 * This is created once at module load time and persists across all HTTP requests.
 * This enables:
 * - Session reconnection (client can disconnect and reconnect to same session)
 * - Multi-client fan-out (multiple clients reading same session)
 * - Proper cleanup (sessions cleaned up when all clients disconnect AND stream completes)
 *
 * Note: In production with multiple server instances, you'd use Redis or a database
 * instead of this in-memory shared storage.
 */
const sharedStorage = createSharedStorage<string>()

// Initializer hook that uses shared storage
const setupDurableStreams = function* (): Operation<void> {
  const { bufferStore, registryStore } = getSharedStores(sharedStorage)
  yield* setupDurableStreamsWithConfig({ bufferStore, registryStore })
}

const setupProvider = function* (ctx: InitializerContext): Operation<void> {
  // Dynamic provider selection based on request
  // Note: provider field is an extension not in the base ChatRequestBody type
  const body = ctx.body as { provider?: string }
  const providerName = body.provider || env.CHAT_PROVIDER
  const providerMap = {
    ollama: ollamaProvider,
    openai: openaiProvider,
  }

  const selectedProvider = providerMap[providerName as keyof typeof providerMap]
  if (!selectedProvider) {
    throw new Error(`Unknown provider: ${providerName}`)
  }

  yield* ProviderContext.set(selectedProvider)
}

const setupTools = function* (_ctx: InitializerContext): Operation<void> {
  yield* ToolRegistryContext.set(allTools)
}

const setupPersonaResolver = function* (_ctx: InitializerContext): Operation<void> {
  yield* PersonaResolverContext.set(resolvePersona)
}

const setupMaxIterations = function* (_ctx: InitializerContext): Operation<void> {
  yield* MaxIterationsContext.set(10)
}

// =============================================================================
// PLUGIN SETUP (MCP plugin tools with React UI elicitation)
// =============================================================================

/**
 * Create a simple MCP tool registry from an array of tools.
 */
function createMcpToolRegistry(mcpTools: { name: string }[]): McpToolRegistry {
  const map = new Map<string, unknown>()
  for (const tool of mcpTools) {
    map.set(tool.name, tool)
  }
  return {
    get: (name: string) => map.get(name),
    has: (name: string) => map.has(name),
    names: () => Array.from(map.keys()),
  }
}

// MCP plugin tools (with elicitation support)
const mcpPluginTools = [bookFlightTool, tictactoeTool, playTttTool]

// Plugin registry (handlers for elicitation)
// Note: Type assertion needed due to TypeScript variance with generic handlers
const pluginRegistry = createPluginRegistryFrom([bookFlightPlugin.client as any, tictactoePlugin.client as any, playTttPlugin.client as any])

// MCP tool registry (for tool lookup)
const mcpToolRegistry = createMcpToolRegistry(mcpPluginTools)

/**
 * Sampling options interface (mirrors ToolSessionSamplingOptions)
 */
interface SamplingOptions {
  systemPrompt?: string
  maxTokens?: number
  tools?: SamplingToolDefinition[]
  toolChoice?: 'auto' | 'required' | 'none'
  schema?: Record<string, unknown>
}

/**
 * Real sampling provider for plugin tools.
 * 
 * This wraps the actual chat provider (Ollama/OpenAI) and:
 * 1. Converts SamplingToolDefinition[] to IsomorphicToolSchema[]
 * 2. Calls the provider's stream() method
 * 3. Collects the result and extracts toolCalls when present
 * 4. Returns properly typed SampleResultBase or SampleResultWithToolCalls
 */
function createPluginSamplingProvider(): ToolSessionSamplingProvider {
  // Determine which provider to use based on env
  const providerName = env.CHAT_PROVIDER
  const provider = providerName === 'openai' ? openaiProvider : ollamaProvider
  
  return {
    *sample(messages, options: SamplingOptions | undefined) {
      // Convert SamplingToolDefinition[] to IsomorphicToolSchema[] format
      const isomorphicToolSchemas = options?.tools?.map((tool: SamplingToolDefinition) => ({
        name: tool.name,
        description: tool.description ?? '',
        parameters: typeof tool.inputSchema === 'object' && 'type' in tool.inputSchema
          ? tool.inputSchema as Record<string, unknown>
          : { type: 'object', properties: {}, required: [] }, // Fallback for Zod schemas (should be pre-converted)
        isIsomorphic: true as const,
        authority: 'server' as const,
      }))

      // Build provider options - only include isomorphicToolSchemas if tools were provided
      const streamOptions = isomorphicToolSchemas && isomorphicToolSchemas.length > 0
        ? { isomorphicToolSchemas }
        : {}

      // Prepend system prompt as a system message if provided
      const messagesWithSystem = options?.systemPrompt
        ? [{ role: 'system' as const, content: options.systemPrompt }, ...messages]
        : messages

      // Call the provider's stream method and collect the result
      const stream = provider.stream(messagesWithSystem, streamOptions)
      
      // Consume the stream to get the final result
      let finalResult: ChatResult | undefined
      
      const subscription = yield* stream
      for (;;) {
        const next = yield* subscription.next()
        if (next.done) {
          finalResult = next.value
          break
        }
        // Ignore streaming events, we just want the final result
      }

      if (!finalResult) {
        return {
          text: '',
          model: provider.name,
          stopReason: 'error',
        } as SampleResultBase
      }

      // Check if the result has tool calls
      if (finalResult.toolCalls && finalResult.toolCalls.length > 0) {
        // Convert ToolCall[] to SamplingToolCall[]
        const samplingToolCalls: SamplingToolCall[] = finalResult.toolCalls.map(tc => ({
          id: tc.id,
          name: tc.function.name,
          arguments: tc.function.arguments,
        }))

        return {
          text: finalResult.text,
          model: provider.name,
          stopReason: 'toolUse',
          toolCalls: samplingToolCalls,
        } as SampleResultWithToolCalls
      }

      // Plain text result
      return {
        text: finalResult.text,
        model: provider.name,
        stopReason: 'endTurn',
      } as SampleResultBase
    },
  }
}

/**
 * Shared plugin session registry and manager (module-level, persists across requests).
 * 
 * CRITICAL: Both must be created in a long-lived Effection scope so that tool
 * sessions survive across HTTP request boundaries. This enables multi-step
 * elicitation flows where:
 * 
 * 1. Request 1: Tool starts, emits pickFlight elicitation, session stays alive
 * 2. Request 2: User selects flight, tool resumes from the same session
 * 3. Request 2: Tool emits pickSeat elicitation, session stays alive
 * 4. Request 3: User selects seat, tool completes
 * 
 * The manager wraps the registry and tracks:
 * - Session wrappers (for server-side sampling)
 * - Last processed LSN per session (to avoid replaying old events on reconnect)
 * 
 * This pattern mirrors how yo-mcp creates its registry at server startup.
 */
let sharedPluginSessionRegistry: ToolSessionRegistry | null = null
let sharedPluginSessionManager: PluginSessionManager | null = null

// Create the registry and manager in a long-lived scope at module initialization
// This runs once when the module is first imported
const registryPromise = run(function* () {
  const store = createInMemoryToolSessionStore()
  const samplingProvider = createPluginSamplingProvider()
  const registry = yield* createToolSessionRegistry(store, { samplingProvider })
  const manager = yield* createPluginSessionManager({ registry })
  sharedPluginSessionRegistry = registry
  sharedPluginSessionManager = manager
  return { registry, manager }
})

const setupPlugins = function* (_ctx: InitializerContext): Operation<void> {
  yield* PluginRegistryContext.set(pluginRegistry)
  yield* McpToolRegistryContext.set(mcpToolRegistry)
  
  // Wait for registry and manager to be ready (they're created async at module load)
  // In practice, they should be ready by the time the first request arrives
  if (!sharedPluginSessionRegistry || !sharedPluginSessionManager) {
    // This shouldn't happen in normal operation, but handle it gracefully
    console.error('Plugin session registry/manager not ready yet')
    return
  }
  
  yield* PluginSessionRegistryContext.set(sharedPluginSessionRegistry)
  yield* PluginSessionManagerContext.set(sharedPluginSessionManager)
}

// Create the handler with hook-based configuration
// IMPORTANT: setupLogger must be first, setupDurableStreams must run before others
const chatHandler = createChatHandler({
  initializerHooks: [
    setupLogger, // Must be first to enable logging in other hooks
    setupDurableStreams,
    setupProvider,
    setupTools,
    setupPersonaResolver,
    setupMaxIterations,
    setupPlugins, // MCP plugin tools with React UI elicitation
  ],
})

export const Route = createFileRoute('/api/chat')({
  server: {
    handlers: {
      POST: async ({ request }) => {
        return chatHandler(request)
      },
    },
  },
})
